<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">






  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-big-counter.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



















  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.1.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/touch-icon-iphone-retina-precomposed.png?v=6.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/touch-icon-iphone-precomposed.png?v=6.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico?v=6.1.0">


  <link rel="mask-icon" href="/touch-icon-ipad-retina-precomposed.png?v=6.1.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":true},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="[toc] nodejs的stream一.  为什么需要流（Stream）？　　举个例子，如果要读取一个文件，一次性读取需要占用大内存，是不可取的。因此就有了流，用流会很方便，可以帮我们避免这样的问题，调用其接口不用关心底层如何实现。 二. 什么是流（Stream）？　　流（Stream）是可读，可写或双工的。可以通过require(‘stream’)加载流的基类，其中包括四类流， Readabl">
<meta name="keywords" content="nodejs">
<meta property="og:type" content="article">
<meta property="og:title" content="nodejs的stream">
<meta property="og:url" content="http://yoursite.com/2018/07/20/2018-07-20-nodejs的stream/index.html">
<meta property="og:site_name" content="﹏ Memory °">
<meta property="og:description" content="[toc] nodejs的stream一.  为什么需要流（Stream）？　　举个例子，如果要读取一个文件，一次性读取需要占用大内存，是不可取的。因此就有了流，用流会很方便，可以帮我们避免这样的问题，调用其接口不用关心底层如何实现。 二. 什么是流（Stream）？　　流（Stream）是可读，可写或双工的。可以通过require(‘stream’)加载流的基类，其中包括四类流， Readabl">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://ww1.sinaimg.cn/mw690/773c8d3dgw1ehi37a16dvj208u03rdft.jpg">
<meta property="og:image" content="http://ww3.sinaimg.cn/mw690/773c8d3dgw1ehi37a9k5zj209m02qdfq.jpg">
<meta property="og:updated_time" content="2018-07-20T07:00:56.352Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="nodejs的stream">
<meta name="twitter:description" content="[toc] nodejs的stream一.  为什么需要流（Stream）？　　举个例子，如果要读取一个文件，一次性读取需要占用大内存，是不可取的。因此就有了流，用流会很方便，可以帮我们避免这样的问题，调用其接口不用关心底层如何实现。 二. 什么是流（Stream）？　　流（Stream）是可读，可写或双工的。可以通过require(‘stream’)加载流的基类，其中包括四类流， Readabl">
<meta name="twitter:image" content="http://ww1.sinaimg.cn/mw690/773c8d3dgw1ehi37a16dvj208u03rdft.jpg">






  <link rel="canonical" href="http://yoursite.com/2018/07/20/2018-07-20-nodejs的stream/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>nodejs的stream | ﹏ Memory °</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">﹏ Memory °</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">修行的路总是孤独的，因为智慧必然来自孤独。</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>




<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
          
  
  <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
</li>

      
        
        
          
  
  <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档<span class="badge">12</span>
      </a>
</li>

      
        
        
          
  
  <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
</li>

      
        
        
          
  
  <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类<span class="badge">10</span>
      </a>
</li>

      
        
        
          
  
  <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签<span class="badge">14</span>
      </a>
</li>

      

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/20/2018-07-20-nodejs的stream/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoumeihui">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://www.gravatar.com/avatar/e87b264d88631de777ecfe2abb602de6?size=128">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="﹏ Memory °">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">nodejs的stream
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-20T18:29:00+08:00">2018-07-20</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/nodejs/" itemprop="url" rel="index"><span itemprop="name">nodejs</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/07/20/2018-07-20-nodejs的stream/" class="leancloud_visitors" data-flag-title="nodejs的stream">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[toc]</p>
<h4 id="nodejs的stream"><a href="#nodejs的stream" class="headerlink" title="nodejs的stream"></a>nodejs的stream</h4><h5 id="一-为什么需要流（Stream）？"><a href="#一-为什么需要流（Stream）？" class="headerlink" title="一.  为什么需要流（Stream）？"></a>一.  为什么需要流（Stream）？</h5><p>　　举个例子，如果要读取一个文件，一次性读取需要占用大内存，是不可取的。因此就有了流，用流会很方便，可以帮我们避免这样的问题，调用其接口不用关心底层如何实现。</p>
<h5 id="二-什么是流（Stream）？"><a href="#二-什么是流（Stream）？" class="headerlink" title="二. 什么是流（Stream）？"></a>二. 什么是流（Stream）？</h5><p>　　流（Stream）是可读，可写或双工的。可以通过require(‘stream’)加载流的基类，其中包括四类流， Readable 流、Writable 流、Duplex 流和Transform 流的基类。</p>
<p>　　另外如果觉得上述四类基类流不能满足需求，可以编写自己的扩充类流。像我们Team现在正做的Node项目，就重写了Transform类以供使用。</p>
<p>按照官方的API文档，步骤如下：</p>
<ul>
<li>在您的子类中扩充适合的父类。（例如util.inherits(MyTransform, Transform); ）</li>
<li>在您的构造函数中调用父类的构造函数，以确保内部的机制被正确初始化。</li>
<li>实现一个或多个特定的方法，参见下面的细节。　</li>
</ul>
<p>在nodejs中，有四种stream类型：</p>
<a id="more"></a>
<ul>
<li>Readable：用来读取数据，比如 fs.createReadStream()。</li>
<li>Writable：用来写数据，比如 fs.createWriteStream()。</li>
<li>Duplex：可读+可写，比如 net.Socket()。</li>
<li>Transform：在读写的过程中，可以对数据进行修改，比如 zlib.createDeflate()（数据压缩/解压）。</li>
</ul>
<h5 id="三-Readable流（可读流）介绍"><a href="#三-Readable流（可读流）介绍" class="headerlink" title="三. Readable流（可读流）介绍"></a>三. Readable流（可读流）介绍</h5><p>　  Readable（可读）流接口是对您正在读取的数据的来源的抽象。换言之，数据出自一个可读流。</p>
<p>　  Readable 流有两种“模式”：流动模式和暂停模式。</p>
<p>　  当处于流动模式时，数据由底层系统读出，并尽可能快地提供给您的程序；当处于暂停模式时，您必须明确地调用 stream.read() 来取出若干数据块。流默认处于暂停模式。</p>
<p>　  </p>
<p>　  A. 通过以下三种方法，可读流会被切换到流动模式</p>
<p>　  　 1. 添加一个’data’事件处理器来监听数据。</p>
<p>　  　 2. 调用 resume()方法来明确开启数据流。</p>
<pre><code>　 3. 调用 pipe()方法将数据发送到一个可写流（Writable）。
</code></pre><p>　  　 之前我一直对pipe()方法有疑问，不清楚其用法。现在了解，当我们用pipe()为可读流指定了一个接受者（可写流）的时候，数据才会真正的被从底层系统读出，传递给可写流。</p>
<p>　  B. 下面介绍Readable流有以下几种事件</p>
<p>　　   1. ‘Readable’事件</p>
<p>　　   2. ‘data’事件 - 数据正在传递时，触发该事件（以chunk数据块为对象）</p>
<p>　　   3. ‘end’事件 - 数据传递完成后，会触发该事件。</p>
<p>　　   4. ‘close’事件</p>
<p>　　   5. ‘error’事件</p>
<p>　　   所有这些事件都可以在官方API文档中找到例子。</p>
<p>　   C. 下面介绍Readable流很重要的一个方法，pipe()方法。</p>
<p>　　   该方法从可读流中拉取所有数据，并写入到所提供的目标（可写流）。该方法能自动控制流量以避免目标被快速读取的可读流所淹没。</p>
<p>　　   值得注意的是，默认情况下，当数据传送完毕，触发’end’事件时，会同时触发目标（可写流）的’end’事件，导致目标不再可写。</p>
<h6 id="举个简单的小例子"><a href="#举个简单的小例子" class="headerlink" title="　　　举个简单的小例子"></a>　　　举个简单的小例子</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1 //http.js</span><br><span class="line"> 2 </span><br><span class="line"> 3 var http = require(&apos;http&apos;);</span><br><span class="line"> 4 var fs = require(&apos;fs&apos;);</span><br><span class="line"> 5 </span><br><span class="line"> 6 http.createServer(function(req, res)&#123;</span><br><span class="line"> 7     var stream = fs.createReadStream(__dirname + &apos;/data.txt&apos;);</span><br><span class="line"> 8     stream.pipe(res);</span><br><span class="line"> 9 &#125;).listen(3000);</span><br><span class="line">10 </span><br><span class="line">11 console.log(&apos;now we are listening 3000 port&apos;);</span><br></pre></td></tr></table></figure>
<p>   data.txt文件内容如下：<br>   <img src="http://ww1.sinaimg.cn/mw690/773c8d3dgw1ehi37a16dvj208u03rdft.jpg" alt="image"></p>
<p>  当执行此段代码后，用户访问<a href="http://127.0.0.1:3000/，会得到如下响应：" target="_blank" rel="noopener">http://127.0.0.1:3000/，会得到如下响应：</a><br>  <img src="http://ww3.sinaimg.cn/mw690/773c8d3dgw1ehi37a9k5zj209m02qdfq.jpg" alt="image"></p>
<p>  此时，创建此Server后，用户访问请求过来，Server会创建一个可读流，当调用stream.pipe(res)为可读流指定目标后，可读流stream会开始从文件data.txt中读取数据，数据写入res（可写流）完毕后，自动调用res的end()方法，结束响应，可写流不再写入。</p>
<p>  第二个例子</p>
<p>  以下都是nodejs中常见的Readable Stream，当然还有其他的，可自行查看文档。</p>
<ul>
<li>http.IncomingRequest</li>
<li>fs.createReadStream()</li>
<li>process.stdin</li>
<li>其他</li>
</ul>
<p><strong>例子一：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">fs.readFile(&apos;./sample.txt&apos;, &apos;utf8&apos;, function(err, content)&#123;</span><br><span class="line">    // 文件读取完成，文件内容是 [你好，我是程序猿小卡]</span><br><span class="line">    console.log(&apos;文件读取完成，文件内容是 [%s]&apos;, content);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>例子二：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">var readStream = fs.createReadStream(&apos;./sample.txt&apos;);</span><br><span class="line">var content = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">readStream.setEncoding(&apos;utf8&apos;);</span><br><span class="line"></span><br><span class="line">readStream.on(&apos;data&apos;, function(chunk)&#123;</span><br><span class="line">    content += chunk;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">readStream.on(&apos;end&apos;, function(chunk)&#123;</span><br><span class="line">    // 文件读取完成，文件内容是 [你好，我是程序猿小卡]</span><br><span class="line">    console.log(&apos;文件读取完成，文件内容是 [%s]&apos;, content);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>例子三：</strong></p>
<p>这里使用了.pipe(dest)，好处在于，如果文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">fs.createReadStream(&apos;./sample.txt&apos;).pipe(process.stdout);</span><br></pre></td></tr></table></figure>
<p>注意：这里只是原封不动的将内容输出到控制台，所以实际上跟前两个例子有细微差异。可以稍做修改，达到上面同样的效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">var onEnd = function()&#123;</span><br><span class="line">    process.stdout.write(&apos;]&apos;);    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var fileStream = fs.createReadStream(&apos;./sample.txt&apos;);</span><br><span class="line">fileStream.on(&apos;end&apos;, onEnd)</span><br><span class="line"></span><br><span class="line">fileStream.pipe(process.stdout);</span><br><span class="line"></span><br><span class="line">process.stdout.write(&apos;文件读取完成，文件内容是[&apos;);</span><br><span class="line"></span><br><span class="line">// 文件读取完成，文件内容是[你好，我是程序猿小卡]</span><br></pre></td></tr></table></figure>
<h5 id="四-Writable流（可写流）介绍"><a href="#四-Writable流（可写流）介绍" class="headerlink" title="四. Writable流（可写流）介绍"></a>四. Writable流（可写流）介绍</h5><p>Writable（可写）流接口是对写入数据的目标的抽象。</p>
<p>　  可写流重要的两个方法，</p>
<p>　  1. write()方法</p>
<p>　　   该方法向底层系统写入数据，并在数据被处理完毕后调用所给的回调。</p>
<p>　  2. end()方法</p>
<p>　　　当不再写入数据时，调用该方法，停止写入。在调用end()后，再调用write()方法会产生错误。</p>
<p>同样以写文件为例子，比如想将hello world写到sample.txt里。</p>
<p><strong>例子一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line">var content = &apos;hello world&apos;;</span><br><span class="line">var filepath = &apos;./sample.txt&apos;;</span><br><span class="line"></span><br><span class="line">fs.writeFile(filepath, content);</span><br></pre></td></tr></table></figure>
<p><strong>例子二：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line">var content = &apos;hello world&apos;;</span><br><span class="line">var filepath = &apos;./sample.txt&apos;;</span><br><span class="line"></span><br><span class="line">var writeStram = fs.createWriteStream(filepath);</span><br><span class="line">writeStram.write(content);</span><br><span class="line">writeStram.end();</span><br></pre></td></tr></table></figure>
<p>五、Duplex Stream</p>
<p>最常见的Duplex stream应该就是net.Socket实例了，在前面的文章里有接触过，这里就直接上代码了，这里包含服务端代码、客户端代码。</p>
<p>服务端代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var net = require(&apos;net&apos;);</span><br><span class="line">var opt = &#123;</span><br><span class="line">    host: &apos;127.0.0.1&apos;,</span><br><span class="line">    port: &apos;3000&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var client = net.connect(opt, function()&#123;</span><br><span class="line">    client.write(&apos;msg from client&apos;);  // 可写</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 可读</span><br><span class="line">client.on(&apos;data&apos;, function(data)&#123;</span><br><span class="line">    // server: msg from client [msg from client]</span><br><span class="line">    console.log(&apos;client: got reply from server [%s]&apos;, data);</span><br><span class="line">    client.end();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>客户端代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var net = require(&apos;net&apos;);</span><br><span class="line">var opt = &#123;</span><br><span class="line">    host: &apos;127.0.0.1&apos;,</span><br><span class="line">    port: &apos;3000&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var client = net.connect(opt, function()&#123;</span><br><span class="line">    client.write(&apos;msg from client&apos;);  // 可写</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 可读</span><br><span class="line">client.on(&apos;data&apos;, function(data)&#123;</span><br><span class="line">    // lient: got reply from server [reply from server]</span><br><span class="line">    console.log(&apos;client: got reply from server [%s]&apos;, data);</span><br><span class="line">    client.end();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>六、Transform Stream<br>Transform stream是Duplex stream的特例，也就是说，Transform stream也同时可读可写。跟Duplex stream的区别点在于，Transform stream的输出与输入是存在相关性的。</p>
<p>常见的Transform stream包括zlib、crypto，这里举个简单例子：文件的gzip压缩。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line">var zlib = require(&apos;zlib&apos;);</span><br><span class="line"></span><br><span class="line">var gzip = zlib.createGzip();</span><br><span class="line"></span><br><span class="line">var inFile = fs.createReadStream(&apos;./extra/fileForCompress.txt&apos;);</span><br><span class="line">var out = fs.createWriteStream(&apos;./extra/fileForCompress.txt.gz&apos;);</span><br><span class="line"></span><br><span class="line">inFile.pipe(gzip).pipe(out);</span><br></pre></td></tr></table></figure>
<h4 id="Node-js-Buffer-缓冲区"><a href="#Node-js-Buffer-缓冲区" class="headerlink" title="Node.js Buffer(缓冲区)"></a>Node.js Buffer(缓冲区)</h4><p>JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。<br>但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。</p>
<p><em>在v6.0之前创建Buffer对象直接使用new Buffer()构造函数来创建对象实例，但是Buffer对内存的权限操作相比很大，可以直接捕获一些敏感信息，所以在v6.0以后，官方文档里面建议使用 Buffer.from() 接口去创建Buffer对象。</em></p>
<h5 id="Buffer-与字符编码"><a href="#Buffer-与字符编码" class="headerlink" title="Buffer 与字符编码"></a>Buffer 与字符编码</h5><p>Buffer 实例一般用于表示编码字符的序列，比如 UTF-8 、 UCS2 、 Base64 、或十六进制编码的数据。 通过使用显式的字符编码，就可以在 Buffer 实例与普通的 JavaScript 字符串之间进行相互转换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const buf = Buffer.from(&apos;runoob&apos;, &apos;ascii&apos;);</span><br><span class="line"></span><br><span class="line">// 输出 72756e6f6f62</span><br><span class="line">console.log(buf.toString(&apos;hex&apos;));</span><br><span class="line"></span><br><span class="line">// 输出 cnVub29i</span><br><span class="line">console.log(buf.toString(&apos;base64&apos;));</span><br></pre></td></tr></table></figure>
<p>Node.js 目前支持的字符编码包括：</p>
<ul>
<li>ascii - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。</li>
<li>utf8 - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。</li>
<li>utf16le - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。</li>
<li>ucs2 - utf16le 的别名。</li>
<li>base64 - Base64 编码。</li>
<li>latin1 - 一种把 Buffer 编码成一字节编码的字符串的方式。</li>
<li>binary - latin1 的别名。</li>
<li>hex - 将每个字节编码为两个十六进制字符。<h5 id="创建-Buffer-类"><a href="#创建-Buffer-类" class="headerlink" title="创建 Buffer 类"></a>创建 Buffer 类</h5>Buffer 提供了以下 API 来创建 Buffer 类：</li>
<li>Buffer.alloc(size[, fill[, encoding]])： 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0</li>
<li>Buffer.allocUnsafe(size)： 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据</li>
<li>Buffer.allocUnsafeSlow(size)</li>
<li>Buffer.from(array)： 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖）</li>
<li>Buffer.from(arrayBuffer[, byteOffset[, length]])： 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。</li>
<li>Buffer.from(buffer)： 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例</li>
<li>Buffer.from(string[, encoding])： 返回一个被 string 的值初始化的新的 Buffer 实例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个长度为 10、且用 0 填充的 Buffer。</span><br><span class="line">const buf1 = Buffer.alloc(10);</span><br><span class="line"></span><br><span class="line">// 创建一个长度为 10、且用 0x1 填充的 Buffer。 </span><br><span class="line">const buf2 = Buffer.alloc(10, 1);</span><br><span class="line"></span><br><span class="line">// 创建一个长度为 10、且未初始化的 Buffer。</span><br><span class="line">// 这个方法比调用 Buffer.alloc() 更快，</span><br><span class="line">// 但返回的 Buffer 实例可能包含旧数据，</span><br><span class="line">// 因此需要使用 fill() 或 write() 重写。</span><br><span class="line">const buf3 = Buffer.allocUnsafe(10);</span><br><span class="line"></span><br><span class="line">// 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。</span><br><span class="line">const buf4 = Buffer.from([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">// 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。</span><br><span class="line">const buf5 = Buffer.from(&apos;tést&apos;);</span><br><span class="line"></span><br><span class="line">// 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。</span><br><span class="line">const buf6 = Buffer.from(&apos;tést&apos;, &apos;latin1&apos;);</span><br></pre></td></tr></table></figure>
<h5 id="写入缓冲区"><a href="#写入缓冲区" class="headerlink" title="写入缓冲区"></a>写入缓冲区</h5><h6 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h6><p>写入 Node 缓冲区的语法如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.write(string[, offset[, length]][, encoding])</span><br></pre></td></tr></table></figure>
<h6 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h6><p>参数描述如下：</p>
<ul>
<li>string - 写入缓冲区的字符串。</li>
<li>offset - 缓冲区开始写入的索引值，默认为 0 。</li>
<li>length - 写入的字节数，默认为 buffer.length</li>
<li>encoding - 使用的编码。默认为 ‘utf8’ 。<br>根据 encoding 的字符编码写入 string 到 buf 中的 offset 位置。 length 参数是写入的字节数。 如果 buf 没有足够的空间保存整个字符串，则只会写入 string 的一部分。 只部分解码的字符不会被写入。<h6 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h6>返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。<h6 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h6></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">buf = Buffer.alloc(256);</span><br><span class="line">len = buf.write(&quot;www.runoob.com&quot;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;写入字节数 : &quot;+  len);</span><br></pre></td></tr></table></figure>
<p>执行以上代码，输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$node main.js</span><br><span class="line">写入字节数 : 14</span><br></pre></td></tr></table></figure>
<h5 id="从缓冲区读取数据"><a href="#从缓冲区读取数据" class="headerlink" title="从缓冲区读取数据"></a>从缓冲区读取数据</h5><h6 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h6><p>读取 Node 缓冲区数据的语法如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.toString([encoding[, start[, end]]])</span><br></pre></td></tr></table></figure>
<h6 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h6><p>参数描述如下：</p>
<ul>
<li>encoding - 使用的编码。默认为 ‘utf8’ 。</li>
<li>start - 指定开始读取的索引位置，默认为 0。</li>
<li>end - 结束位置，默认为缓冲区的末尾。<h6 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h6>解码缓冲区数据并使用指定的编码返回字符串。<h6 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h6></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">buf = Buffer.alloc(26);</span><br><span class="line">for (var i = 0 ; i &lt; 26 ; i++) &#123;</span><br><span class="line">  buf[i] = i + 97;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log( buf.toString(&apos;ascii&apos;));       // 输出: abcdefghijklmnopqrstuvwxyz</span><br><span class="line">console.log( buf.toString(&apos;ascii&apos;,0,5));   // 输出: abcde</span><br><span class="line">console.log( buf.toString(&apos;utf8&apos;,0,5));    // 输出: abcde</span><br><span class="line">console.log( buf.toString(undefined,0,5)); // 使用 &apos;utf8&apos; 编码, 并输出: abcde</span><br></pre></td></tr></table></figure>
<p>执行以上代码，输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">abcde</span><br><span class="line">abcde</span><br><span class="line">abcde</span><br></pre></td></tr></table></figure>
<h5 id="将-Buffer-转换为-JSON-对象"><a href="#将-Buffer-转换为-JSON-对象" class="headerlink" title="将 Buffer 转换为 JSON 对象"></a>将 Buffer 转换为 JSON 对象</h5><h6 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h6><p>将 Node Buffer 转换为 JSON 对象的函数语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.toJSON()</span><br></pre></td></tr></table></figure>
<p>当字符串化一个 Buffer 实例时，JSON.stringify() 会隐式地调用该 toJSON()。</p>
<h6 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h6><p>返回 JSON 对象。</p>
<h6 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);</span><br><span class="line">const json = JSON.stringify(buf);</span><br><span class="line"></span><br><span class="line">// 输出: &#123;&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]&#125;</span><br><span class="line">console.log(json);</span><br><span class="line"></span><br><span class="line">const copy = JSON.parse(json, (key, value) =&gt; &#123;</span><br><span class="line">  return value &amp;&amp; value.type === &apos;Buffer&apos; ?</span><br><span class="line">    Buffer.from(value.data) :</span><br><span class="line">    value;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 输出: &lt;Buffer 01 02 03 04 05&gt;</span><br><span class="line">console.log(copy);</span><br></pre></td></tr></table></figure>
<p>执行以上代码，输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]&#125;</span><br><span class="line">&lt;Buffer 01 02 03 04 05&gt;</span><br></pre></td></tr></table></figure>
<h5 id="缓冲区合并"><a href="#缓冲区合并" class="headerlink" title="缓冲区合并"></a>缓冲区合并</h5><h6 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h6><p>Node 缓冲区合并的语法如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Buffer.concat(list[, totalLength])</span><br></pre></td></tr></table></figure>
<h6 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h6><p>参数描述如下：</p>
<ul>
<li>list - 用于合并的 Buffer 对象数组列表。</li>
<li>totalLength - 指定合并后Buffer对象的总长度。<h6 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h6>返回一个多个成员合并的新 Buffer 对象。<h6 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h6></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var buffer1 = Buffer.from((&apos;菜鸟教程&apos;));</span><br><span class="line">var buffer2 = Buffer.from((&apos;www.runoob.com&apos;));</span><br><span class="line">var buffer3 = Buffer.concat([buffer1,buffer2]);</span><br><span class="line">console.log(&quot;buffer3 内容: &quot; + buffer3.toString());</span><br></pre></td></tr></table></figure>
<p>执行以上代码，输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer3 内容: 菜鸟教程 www.runoob.com</span><br></pre></td></tr></table></figure>
<h5 id="缓冲区比较"><a href="#缓冲区比较" class="headerlink" title="缓冲区比较"></a>缓冲区比较</h5><h6 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h6><p>Node Buffer 比较的函数语法如下所示, 该方法在 Node.js v0.12.2 版本引入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.compare(otherBuffer);</span><br></pre></td></tr></table></figure>
<h6 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h6><p>参数描述如下：</p>
<ul>
<li>otherBuffer - 与 buf 对象比较的另外一个 Buffer 对象。<h6 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h6>返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同。<h6 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h6></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var buffer1 = Buffer.from(&apos;ABC&apos;);</span><br><span class="line">var buffer2 = Buffer.from(&apos;ABCD&apos;);</span><br><span class="line">var result = buffer1.compare(buffer2);</span><br><span class="line"></span><br><span class="line">if(result &lt; 0) &#123;</span><br><span class="line">   console.log(buffer1 + &quot; 在 &quot; + buffer2 + &quot;之前&quot;);</span><br><span class="line">&#125;else if(result == 0)&#123;</span><br><span class="line">   console.log(buffer1 + &quot; 与 &quot; + buffer2 + &quot;相同&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">   console.log(buffer1 + &quot; 在 &quot; + buffer2 + &quot;之后&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行以上代码，输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABC在ABCD之前</span><br></pre></td></tr></table></figure>
<h5 id="拷贝缓冲区"><a href="#拷贝缓冲区" class="headerlink" title="拷贝缓冲区"></a>拷贝缓冲区</h5><h6 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h6><p>Node 缓冲区拷贝语法如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])</span><br></pre></td></tr></table></figure>
<h6 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h6><p>参数描述如下：</p>
<ul>
<li>targetBuffer - 要拷贝的 Buffer 对象。</li>
<li>targetStart - 数字, 可选, 默认: 0</li>
<li>sourceStart - 数字, 可选, 默认: 0</li>
<li>sourceEnd - 数字, 可选, 默认: buffer.length<h6 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h6>没有返回值。<h6 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h6></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var buf1 = Buffer.from(&apos;abcdefghijkl&apos;);</span><br><span class="line">var buf2 = Buffer.from(&apos;RUNOOB&apos;);</span><br><span class="line"></span><br><span class="line">//将 buf2 插入到 buf1 指定位置上</span><br><span class="line">buf2.copy(buf1, 2);</span><br><span class="line"></span><br><span class="line">console.log(buf1.toString());</span><br></pre></td></tr></table></figure>
<p>执行以上代码，输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abRUNOOBijkl</span><br></pre></td></tr></table></figure>
<h5 id="缓冲区裁剪"><a href="#缓冲区裁剪" class="headerlink" title="缓冲区裁剪"></a>缓冲区裁剪</h5><p>Node 缓冲区裁剪语法如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.slice([start[, end]])</span><br></pre></td></tr></table></figure>
<h6 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h6><p>参数描述如下：</p>
<ul>
<li>start - 数字, 可选, 默认: 0</li>
<li>end - 数字, 可选, 默认: buffer.length<h6 id="返回值-6"><a href="#返回值-6" class="headerlink" title="返回值"></a>返回值</h6>返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引 start 到 end 的位置剪切。<h6 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h6></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var buffer1 = Buffer.from(&apos;runoob&apos;);</span><br><span class="line">// 剪切缓冲区</span><br><span class="line">var buffer2 = buffer1.slice(0,2);</span><br><span class="line">console.log(&quot;buffer2 content: &quot; + buffer2.toString());</span><br></pre></td></tr></table></figure>
<p>执行以上代码，输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer2 content: ru</span><br></pre></td></tr></table></figure>
<h5 id="缓冲区长度"><a href="#缓冲区长度" class="headerlink" title="缓冲区长度"></a>缓冲区长度</h5><h6 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h6><p>Node 缓冲区长度计算语法如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.length;</span><br></pre></td></tr></table></figure>
<h6 id="返回值-7"><a href="#返回值-7" class="headerlink" title="返回值"></a>返回值</h6><p>返回 Buffer 对象所占据的内存长度。</p>
<h6 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var buffer = Buffer.from(&apos;www.runoob.com&apos;);</span><br><span class="line">//  缓冲区长度</span><br><span class="line">console.log(&quot;buffer length: &quot; + buffer.length);</span><br></pre></td></tr></table></figure>
<p>执行以上代码，输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer length: 14</span><br></pre></td></tr></table></figure>
<h4 id="Stream和Buffer"><a href="#Stream和Buffer" class="headerlink" title="Stream和Buffer"></a>Stream和Buffer</h4><h5 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h5><p>在一个应用程序中，流是一组有序的、有起点和终点的字节数据的传输手段。</p>
<h5 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h5><p>用于创建一个专门存放二进制数据的缓存区</p>
<h6 id="1-1-Stream"><a href="#1-1-Stream" class="headerlink" title="1.1 Stream"></a>1.1 Stream</h6><p>Stream 有四种流类型，且所有的 Stream 对象都是 EventEmitter 的实例： </p>
<ul>
<li>Readable – 可读操作。 </li>
<li>Writable – 可写操作。 </li>
<li>Duplex – 可读可写操作. </li>
<li>Transform – 操作被写入数据，然后读出结果。</li>
</ul>
<p>这意味着Stream对象有四种，同时每个Stream对象都有他们对应的事情。这些事件会在下文阐述。</p>
<h6 id="1-2-Buffer"><a href="#1-2-Buffer" class="headerlink" title="1.2 Buffer"></a>1.2 Buffer</h6><p>NodeJS的Buffer详解：<a href="http://www.cnblogs.com/dwj0931-node/p/5397986.html" target="_blank" rel="noopener">http://www.cnblogs.com/dwj0931-node/p/5397986.html</a></p>
<ul>
<li>Buffer的用途：文件传输或者大数据传输</li>
<li>Buffer的字节管理</li>
<li>Buffer对象与其他对象的转换</li>
<li>Buffer的保存<h6 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h6></li>
</ul>
<ol>
<li><p>在后端中应用，因为在后端与前端、后端的IO中，很大机会会出现文件太大，不能一次性读取的问题。因此在前端中使用的方法：整体读取后再进行操作，会导致程序的等待时间过长，因此，流操作（stream）便营运而生。</p>
</li>
<li><p>在readable和writable的Stream之间筑起沟通，如果仅仅使用事件方法来进行的话，代码会显得很冗杂，因此需要出现pipe（管道）方法来进行。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">readable.pipe(writable);</span><br><span class="line">//返回值为writable的对象</span><br></pre></td></tr></table></figure>
<ol>
<li>在数据传输过程中，如果需要把其中一段Stream截取并且进行修改查看，则需要Buffer类来进行协助，并且转化成其他的人类可理解对象<h5 id="How"><a href="#How" class="headerlink" title="How"></a>How</h5></li>
</ol>
<p>所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有： </p>
<ul>
<li>data – 当有数据可读时触发。 </li>
<li>end – 没有更多的数据可读时触发。 </li>
<li>error – 在接收和写入过程中发生错误时触发。 </li>
<li>finish – 所有数据已被写入到底层系统时触发。 </li>
<li>drain—缓冲区已满</li>
</ul>
<ol>
<li><p>在文件流读取、写入中，有特定的事件可以提供监听。</p>
</li>
<li><p>在读取到的二进制Bytes中，如何把字节重新解读成我们需要的数据<br>通常传输的文件是图片、音频、视频等文件，中间程序要处理的有（百分比评估、是否传输完成、再一次传输给别的地方等），而不会在传输过程中要求打开修改文件（又不是迅雷那种边下载边看 </p>
</li>
</ol>
<p>setEncoding和Buffer</p>
<ol start="3">
<li><p>前端如何以流的方式发送信息给后端（socket）</p>
<ol>
<li><p>可操作的流：socket、webSocket。</p>
<p> 以socket形式传输的流，前端是可以控制传输的量，并且得到反馈的。例如传输一张图片，用流（二进制）的方式来传输，可以精确到传输的百分比、断点续传等功能。</p>
</li>
<li><p>一次性的流：http </p>
<p> HTTP传输的Request和Response，则是一次性后端读取到一系列信息，但是后端在处理的时候，是完全可以用Readable Stream的形式来读取的。</p>
</li>
</ol>
</li>
</ol>
<h5 id="Different"><a href="#Different" class="headerlink" title="Different"></a>Different</h5><p>Stream与readFile、readFileSync<br>Stream是每次读取一部分进入缓冲区，并且根据开发者定义的事件进行处理。 </p>
<p>而ReadFile、ReaderFileSync这些则是异步（或者同步）一次性把文件读取进入缓冲区，然后再进行操作。</p>
<h5 id="Scene-应用场景）"><a href="#Scene-应用场景）" class="headerlink" title="Scene(应用场景）"></a>Scene(应用场景）</h5><h6 id="5-1-Stream的使用场景"><a href="#5-1-Stream的使用场景" class="headerlink" title="5.1 Stream的使用场景"></a>5.1 Stream的使用场景</h6><p>大文件传输（不能短期阻塞完成的）<br>文件需要多次传输的，使用pipe（防止代码过于冗杂）</p>
<h6 id="5-2-Buffer的使用场景"><a href="#5-2-Buffer的使用场景" class="headerlink" title="5.2 Buffer的使用场景"></a>5.2 Buffer的使用场景</h6><p>需要操作流的时候（大文件、大量数据）</p>
<h5 id="nodejs-buffer-stream区别"><a href="#nodejs-buffer-stream区别" class="headerlink" title="nodejs buffer stream区别"></a>nodejs buffer stream区别</h5><h6 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h6><p>为数据缓冲对象，是一个类似数组结构的对象，可以通过指定开始写入的位置及写入的数据长度，往其中写入二进制数据。 </p>
<h6 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h6><p>是对buffer对象的高级封装，其操作的底层还是buffer对象，stream可以设置为可读、可写，或者即可读也可写，在nodejs中继承了EventEmitter接口，可以监听读入、写入的过程。具体实现有文件流，httpresponse等</p>
<h4 id="Node-js-Buffer-缓冲区-和Stream流的关系"><a href="#Node-js-Buffer-缓冲区-和Stream流的关系" class="headerlink" title="Node.js Buffer(缓冲区)和Stream流的关系"></a>Node.js Buffer(缓冲区)和Stream流的关系</h4><p> JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。处理文件流和处理TCP流（如文件之间传数据），必须使用到二进制数据，因此有了Buffer类，该类用来创建一个专门存放二进制数据的缓存区。</p>
<pre><code>以下为管道流实现文件传输的例子：
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);  </span><br><span class="line">  </span><br><span class="line">// 创建一个可读流  </span><br><span class="line">var readerStream = fs.createReadStream(&apos;input.txt&apos;);  </span><br><span class="line">  </span><br><span class="line">// 创建一个可写流  </span><br><span class="line">var writerStream = fs.createWriteStream(&apos;output.txt&apos;);  </span><br><span class="line">  </span><br><span class="line">// 管道读写操作  </span><br><span class="line">// 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中  </span><br><span class="line">readerStream.pipe(writerStream);  </span><br><span class="line">  </span><br><span class="line">console.log(&quot;程序执行完毕&quot;);</span><br></pre></td></tr></table></figure>
<p>  pipe()方法实现文件数据的复制，个人认为pipe()封装了一些Buffer类的方法，如将可读流中的数据转化为二进制并存入缓冲区：Buffer.from(“可读流中的数据”)。整个程序好像以下过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const buf1=Buffer.from(&quot;input.txt中的数据&quot;)//将input.txt中的数据转华为二进制数据  </span><br><span class="line">const buf2=Buffer.from(&quot;output.txt中的数据&quot;)//将output.txt中的数据转华为二进制数据  </span><br><span class="line">buf2.copy(buf1);//复制buf1中的二进制数据  </span><br><span class="line">buf1.toString()  </span><br><span class="line">buf2.toString()//输出复制后output.txt的数据</span><br></pre></td></tr></table></figure>
<h4 id="vue组件之间的通信"><a href="#vue组件之间的通信" class="headerlink" title="vue组件之间的通信"></a>vue组件之间的通信</h4><p><strong>组件关系有下面三种：父–&gt;子、子–&gt;父、非父子</strong></p>
<h5 id="父组件向子组件传递数据"><a href="#父组件向子组件传递数据" class="headerlink" title="父组件向子组件传递数据"></a>父组件向子组件传递数据</h5><p>父组件一共需要做4件事</p>
<p>1.import son from ‘./son.js’ 引入子组件 son</p>
<p>2.在components : {“son”} 里注册所有子组件名称</p>
<p>3.在父组件的template应用子组件, <son></son></p>
<p>4.如果需要传递数据给子组件,就在template模板里写 <son :num="number"></son></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 1.引入子组件 </span><br><span class="line">    import counter from &apos;./counter&apos;     import son from &apos;./son&apos;</span><br><span class="line"></span><br><span class="line">// 2.在ccmponents里注册子组件    </span><br><span class="line">components : &#123;</span><br><span class="line">        counter,</span><br><span class="line">        son</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">// 3.在template里使用子组件  </span><br><span class="line">&lt;son&gt;&lt;/son&gt;</span><br><span class="line"></span><br><span class="line">// 4.如果需要传递数据,也是在templete里写</span><br><span class="line"> </span><br><span class="line">  &lt;counter :num=&quot;number&quot;&gt;&lt;/counter&gt;</span><br></pre></td></tr></table></figure>
<p>子组件只需要做1件事</p>
<p>1.用props接受数据,就可以直接使用数据</p>
<p>2.子组件接受到的数据,不能去修改。如果你的确需要修改,可以用计算属性,或者把数据赋值给子组件data里的一个变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 1.用Props接受数据     </span><br><span class="line">    props: [              </span><br><span class="line">        &apos;num&apos;</span><br><span class="line">        ],</span><br><span class="line"></span><br><span class="line">// 2.如果需要修改得到的数据,可以这样写</span><br><span class="line">   props: [           </span><br><span class="line">            &apos;num&apos;</span><br><span class="line">        ],  </span><br><span class="line">        data () &#123;       </span><br><span class="line">            return &#123;</span><br><span class="line">                number : this.num</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br></pre></td></tr></table></figure>
<h5 id="子组件向父组件传递数据"><a href="#子组件向父组件传递数据" class="headerlink" title="子组件向父组件传递数据"></a>子组件向父组件传递数据</h5><p>子组件一共需要1件事情</p>
<p>在数据变化后,用$emit触发即可</p>
<p>// 1. 子组件在数据变化后,用$emit触发即可,第二个参数可以传递参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">        increment()&#123;                  </span><br><span class="line">        this.number++                    </span><br><span class="line">        this.$emit(&apos;changeNumber&apos;, this.number)&#125;,</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>父组件一共需要做2件事情</p>
<p>在template里定义事件</p>
<p>在methods里写函数,监听子组件的事件触发</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 1. 在templete里应用子组件时,定义事件changeNumber</span><br><span class="line">      &lt;counter :num=&quot;number&quot;                 </span><br><span class="line">      @changeNumber=&quot;changeNumber&quot;</span><br><span class="line">      &gt;</span><br><span class="line">      &lt;/counter&gt;</span><br><span class="line"></span><br><span class="line">// 2. 用changeNumber监听事件是否触发</span><br><span class="line">        methods: &#123;</span><br><span class="line">            changeNumber(e)&#123;            </span><br><span class="line">                console.log(&apos;子组件emit了&apos;,e);      </span><br><span class="line">                this.number = e</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h5 id="第二种通信方式-eventBus"><a href="#第二种通信方式-eventBus" class="headerlink" title="第二种通信方式: eventBus"></a>第二种通信方式: eventBus</h5><p>eventBus这种通信方式,针对的是非父子组件之间的通信,它的原理还是通过事件的触发和监听。</p>
<p>但是因为是非父子组件的关系,他们需要有一个中间组件来连接。</p>
<p>我是使用的通过在根组件,也就是#app组件上定义了一个所有组件都可以访问到的组件,具体使用方式如下</p>
<p>使用eventBus传递数据,我们一共需要做3件事情</p>
<p>1.给app组件添加Bus属性 (这样所有组件都可以通过this.$root.Bus访问到它,而且不需要引入任何文件)</p>
<p>2.在组件1里,this.$root.Bus.$emit触发事件</p>
<p>3.在组件2里,this.$root.Bus.$on监听事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 1.在main.js里给app组件,添加bus属性</span><br><span class="line">import Vue from &apos;vue&apos;new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  components: &#123; App &#125;,  </span><br><span class="line">  template: &apos;&lt;App/&gt;&apos;,</span><br><span class="line">  data()&#123;   </span><br><span class="line">        return &#123;</span><br><span class="line">            Bus : new Vue()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// 或者</span><br><span class="line">**main.js**</span><br><span class="line">let bus = new Vue()</span><br><span class="line">Vue.prototype.bus = bus</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 2.在组件1里,触发,</span><br><span class="line">//使用bus.$emit(&apos;事件名称&apos;，&apos;传入参数&apos;)，作为发送消息的那一方；</span><br><span class="line">emitincrement()&#123;</span><br><span class="line">        this.number++</span><br><span class="line">        this.$root.Bus.$emit(&apos;eventName&apos;, this.number)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 3.在组件2里,监听事件,接受数据</span><br><span class="line">// 使用bus.$on(&apos;事件名称&apos;，&apos;回调函数&apos;)，作为接收消息的那一方</span><br><span class="line">mounted()&#123;    </span><br><span class="line">    this.$root.Bus.$on(&apos;eventName&apos;, value =&gt; &#123;        </span><br><span class="line">        this.number = value</span><br><span class="line">        console.log(&apos;busEvent&apos;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="第三种通信方式-利用localStorage或者sessionStorage"><a href="#第三种通信方式-利用localStorage或者sessionStorage" class="headerlink" title="第三种通信方式: 利用localStorage或者sessionStorage"></a>第三种通信方式: 利用localStorage或者sessionStorage</h5><p>这种通信比较简单,缺点是数据和状态比较混乱,不太容易维护。</p>
<ul>
<li>通过window.localStorage.getItem(key) 获取数据</li>
<li>通过window.localStorage.setItem(key,value) 存储数据</li>
</ul>
<p><em>注意用JSON.parse() / JSON.stringify()</em> 做数据格式转换。</p>
<h5 id="第四种通信方式-利用Vuex"><a href="#第四种通信方式-利用Vuex" class="headerlink" title="第四种通信方式: 利用Vuex()"></a>第四种通信方式: 利用Vuex()</h5><p>官方文档：<a href="http://vuex.vuejs.org" target="_blank" rel="noopener">http://vuex.vuejs.org</a><br>–vuex：主要用来集中式管理组件状态，（如组件显示/隐藏，增加/减少）</p>
<p>1)启动一个项目</p>
<p>2)安装vuex：cnpm install vuex -D</p>
<p>3）vuex提供了两个非常好的方法：</p>
<ul>
<li>mapActions():可以将所有methods里面的方法，进行打包。即对所有的事件(或我们的行为)进行管理</li>
<li>mapGetters：获取所有的数据，对所有的数据进行管理</li>
</ul>
<p>4）vuex的工作过程：</p>
<ol>
<li>当用户点击时，会调用increment函数(即用户有一个动作dispatch)</li>
</ol>
<ul>
<li>　　mapActions将函数(动作dispatch)提交到actions里面，并且传了commit这个参数(也是一个函数)</li>
</ul>
<ol start="2">
<li>commit主要处理你要做什么，比如异步请求，判断，流程控制等，commit会将这些请求、状态提交到mutations里面</li>
<li>mutations主要用来处理状态(数据)的变化</li>
<li>mapGetters获取目前数据，将状态(数据)提交到getters上面，给mutations使用，让数据发生变化，<br>　　并返回(render)，从而更新视图</li>
</ol>
<p>5）actions里面除了含有commit这的对象参数以外，还有另一个参数state(Vue组件中展示的数据源)</p>
<p>　　在这个过程中可以对数据进行判断，并作出相应的操作
　　</p>
<p>例子在src1/store.js中，这里是没有改写之前的代码</p>
<p>官方的文档中指出，vuex工作的各个过程是拆分开来实现的，下面我们就来进行一些分文件实现<br>项目的目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">|--src文件夹</span><br><span class="line">　　|--App.vue</span><br><span class="line">　　|--main.js</span><br><span class="line">　　|--store文件夹</span><br><span class="line">　　　　|--index.js	//必须有index.js，它是我们组装模块并导出 store 的地方</span><br><span class="line">　　　　|--actions.js	//是我们有动作触发之后，dispatch提交的地方</span><br><span class="line">　　　　|--mutations.js	//commit提交的地方</span><br><span class="line">　　　　|--types.js	//存放的是控制数据状态的地方，即控制数据如何变化</span><br><span class="line">　　　　|--getters.js	//获取数据的目前状态，给mutations使用</span><br></pre></td></tr></table></figure>
<h4 id="axios中文文档"><a href="#axios中文文档" class="headerlink" title="axios中文文档"></a>axios中文文档</h4><h5 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h5><p>基于http客户端的promise，面向浏览器和nodejs</p>
<h5 id="特色"><a href="#特色" class="headerlink" title="特色"></a>特色</h5><p>浏览器端发起XMLHttpRequests请求</p>
<p>node端发起http请求</p>
<p>支持Promise API</p>
<p>监听请求和返回</p>
<p>转化请求和返回</p>
<p>取消请求</p>
<p>自动转化json数据</p>
<p>客户端支持抵御</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><h6 id="使用一个-GET-请求"><a href="#使用一个-GET-请求" class="headerlink" title="使用一个 GET 请求"></a>使用一个 GET 请求</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//发起一个user请求，参数为给定的ID</span><br><span class="line">axios.get(&apos;/user?ID=1234&apos;)</span><br><span class="line">.then(function(respone)&#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function(error)&#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//上面的请求也可选择下面的方式来写</span><br><span class="line">axios.get(&apos;/user&apos;,&#123;</span><br><span class="line">    params:&#123;</span><br><span class="line">        ID:12345</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">    .then(function(response)&#123;</span><br><span class="line">        console.log(response);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(function(error)&#123;</span><br><span class="line">        console.log(error)</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h6 id="发起一个-POST-请求"><a href="#发起一个-POST-请求" class="headerlink" title="发起一个 POST 请求"></a>发起一个 POST 请求</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios.post(&apos;/user&apos;,&#123;</span><br><span class="line">    firstName:&apos;friend&apos;,</span><br><span class="line">    lastName:&apos;Flintstone&apos;</span><br><span class="line">&#125;)</span><br><span class="line">.then(function(response)&#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function(error)&#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h6 id="发起一个多重并发请求"><a href="#发起一个多重并发请求" class="headerlink" title="发起一个多重并发请求"></a>发起一个多重并发请求</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function getUserAccount()&#123;</span><br><span class="line">    return axios.get(&apos;/user/12345&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getUserPermissions()&#123;</span><br><span class="line">    return axios.get(&apos;/user/12345/permissions&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">axios.all([getUerAccount(),getUserPermissions()])</span><br><span class="line">    .then(axios.spread(function(acc,pers)&#123;</span><br><span class="line">        //两个请求现在都完成</span><br><span class="line">    &#125;));</span><br></pre></td></tr></table></figure>
<h5 id="axios-API"><a href="#axios-API" class="headerlink" title="axios API"></a>axios API</h5><p>axios 能够在进行请求时进行一些设置。</p>
<p>axios(config)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//发起 POST请求</span><br><span class="line"></span><br><span class="line">axios(&#123;</span><br><span class="line">    method:&apos;post&apos;,</span><br><span class="line">    url:&apos;/user/12345&apos;,</span><br><span class="line">    data:&#123;</span><br><span class="line">        firstName:&apos;Fred&apos;,</span><br><span class="line">        lastName:&apos;Flintstone&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">axios(url[,config])</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//发起一个GET请求</span><br><span class="line">axios(&apos;/user/12345/);</span><br></pre></td></tr></table></figure>
<h5 id="请求方法的重命名。"><a href="#请求方法的重命名。" class="headerlink" title="请求方法的重命名。"></a>请求方法的重命名。</h5><p>为了方便，axios提供了所有请求方法的重命名支持</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">axios.request(config)</span><br><span class="line"></span><br><span class="line">axios.get(url[,config])</span><br><span class="line"></span><br><span class="line">axios.delete(url[,config])</span><br><span class="line"></span><br><span class="line">axios.head(url[,config])</span><br><span class="line"></span><br><span class="line">axios.post(url[,data[,config]])</span><br><span class="line"></span><br><span class="line">axios.put(url[,data[,config]])</span><br><span class="line"></span><br><span class="line">axios.patch(url[,data[,config]])</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>当时用重命名方法时 url , method ,以及 data 特性不需要在config中设置。</p>
<h5 id="并发-Concurrency"><a href="#并发-Concurrency" class="headerlink" title="并发 Concurrency"></a>并发 Concurrency</h5><p>有用的方法</p>
<p>axios.all(iterable)</p>
<p>axios.spread(callback)</p>
<h6 id="创建一个实例"><a href="#创建一个实例" class="headerlink" title="创建一个实例"></a>创建一个实例</h6><p>你可以使用自定义设置创建一个新的实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.create([config])</span><br><span class="line"></span><br><span class="line">var instance = axios.create(&#123;</span><br><span class="line">    baseURL:&apos;http://some-domain.com/api/&apos;,</span><br><span class="line">    timeout:1000,</span><br><span class="line">    headers:&#123;&apos;X-Custom-Header&apos;:&apos;foobar&apos;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h6 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h6><p>下面列出了一些实例方法。具体的设置将在实例设置中被合并。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">axios#request(config)</span><br><span class="line"></span><br><span class="line">axios#get(url[,config])</span><br><span class="line"></span><br><span class="line">axios#delete(url[,config])</span><br><span class="line"></span><br><span class="line">axios#head(url[,config])</span><br><span class="line"></span><br><span class="line">axios#post(url[,data[,config]])</span><br><span class="line"></span><br><span class="line">axios#put(url[,data[,config]])</span><br><span class="line"></span><br><span class="line">axios#patch(url[,data[,config]])</span><br></pre></td></tr></table></figure>
<h5 id="请求设置"><a href="#请求设置" class="headerlink" title="请求设置"></a>请求设置</h5><p>以下列出了一些请求时的设置。只有 url 是必须的，如果没有指明的话，默认的请求方法是GET .</p>
<h5 id="返回响应概要-Response-Schema"><a href="#返回响应概要-Response-Schema" class="headerlink" title="返回响应概要 Response Schema"></a>返回响应概要 Response Schema</h5><p>一个请求的返回包含以下信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    //`data`是服务器的提供的回复（相对于请求）</span><br><span class="line">    data&#123;&#125;,</span><br><span class="line"></span><br><span class="line">    //`status`是服务器返回的http状态码</span><br><span class="line">    status:200,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //`statusText`是服务器返回的http状态信息</span><br><span class="line">    statusText: &apos;ok&apos;,</span><br><span class="line"></span><br><span class="line">    //`headers`是服务器返回中携带的headers</span><br><span class="line">    headers:&#123;&#125;,</span><br><span class="line"></span><br><span class="line">    //`config`是对axios进行的设置，目的是为了请求（request）</span><br><span class="line">    config:&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 then ，你会接受打下面的信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.get(&apos;/user/12345&apos;)</span><br><span class="line">    .then(function(response)&#123;</span><br><span class="line">        console.log(response.data);</span><br><span class="line">        console.log(response.status);</span><br><span class="line">        console.log(response.statusText);</span><br><span class="line">        console.log(response.headers);</span><br><span class="line">        console.log(response.config);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>使用 catch 时，或者传入一个 reject callback 作为 then 的第二个参数，那么返回的错误信息将能够被使用。</p>
<h5 id="默认设置（Config-Default"><a href="#默认设置（Config-Default" class="headerlink" title="默认设置（Config Default)"></a>默认设置（Config Default)</h5><p>你可以设置一个默认的设置，这设置将在所有的请求中有效。</p>
<h5 id="全局默认设置-Global-axios-defaults"><a href="#全局默认设置-Global-axios-defaults" class="headerlink" title="全局默认设置 Global axios defaults"></a>全局默认设置 Global axios defaults</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.baseURL = &apos;https://api.example.com&apos;;</span><br><span class="line">axios.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN;</span><br><span class="line">axios.defaults.headers.post[&apos;Content-Type&apos;]=&apos;application/x-www-form-urlencoded&apos;;</span><br></pre></td></tr></table></figure>
<h5 id="实例中自定义默认值-Custom-instance-default"><a href="#实例中自定义默认值-Custom-instance-default" class="headerlink" title="实例中自定义默认值 Custom instance default"></a>实例中自定义默认值 Custom instance default</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//当创建一个实例时进行默认设置</span><br><span class="line">var instance = axios.create(&#123;</span><br><span class="line">    baseURL:&apos;https://api.example.com&apos;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//在实例创建之后改变默认值</span><br><span class="line">instance.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN;</span><br></pre></td></tr></table></figure>
<h5 id="设置优先级-Config-order-of-precedence"><a href="#设置优先级-Config-order-of-precedence" class="headerlink" title="设置优先级 Config order of precedence"></a>设置优先级 Config order of precedence</h5><p>设置(config)将按照优先顺序整合起来。首先的是在 lib/defaults.js 中定义的默认设置，其次是 defaults 实例属性的设置，最后是请求中 config 参数的设置。越往后面的等级越高，会覆盖前面的设置。</p>
<p>看下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//使用默认库的设置创建一个实例，</span><br><span class="line">//这个实例中，使用的是默认库的timeout设置，默认值是0。</span><br><span class="line">var instance = axios.create();</span><br><span class="line"></span><br><span class="line">//覆盖默认库中timeout的默认值</span><br><span class="line">//此时，所有的请求的timeout时间是2.5秒</span><br><span class="line">instance.defaults.timeout = 2500;</span><br><span class="line"></span><br><span class="line">//覆盖该次请求中timeout的值，这个值设置的时间更长一些</span><br><span class="line">instance.get(&apos;/longRequest&apos;,&#123;</span><br><span class="line">    timeout:5000</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="拦截器-interceptors"><a href="#拦截器-interceptors" class="headerlink" title="拦截器 interceptors"></a>拦截器 interceptors</h5><p>你可以在 请求 或者 返回 被 then 或者 catch 处理之前对他们进行拦截。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//添加一个请求拦截器</span><br><span class="line">axios.interceptors.request.use(function(config)&#123;</span><br><span class="line">    //在请求发送之前做一些事</span><br><span class="line">    return config;</span><br><span class="line">&#125;,function(error)&#123;</span><br><span class="line">    //当出现请求错误是做一些事</span><br><span class="line">    return Promise.reject(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//添加一个返回拦截器</span><br><span class="line">axios.interceptors.response.use(function(response)&#123;</span><br><span class="line">    //对返回的数据进行一些处理</span><br><span class="line">    return response;</span><br><span class="line">&#125;,function(error)&#123;</span><br><span class="line">    //对返回的错误进行一些处理</span><br><span class="line">    return Promise.reject(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果你需要在稍后移除拦截器,你可以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var myInterceptor = axios.interceptors.request.use(function()&#123;/*...*/&#125;);</span><br><span class="line">axios.interceptors.rquest.eject(myInterceptor);</span><br></pre></td></tr></table></figure>
<p>你可以在一个axios实例中使用拦截器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var instance = axios.create();</span><br><span class="line">instance.interceptors.request.use(function()&#123;/*...*/&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="错误处理-Handling-Errors"><a href="#错误处理-Handling-Errors" class="headerlink" title="错误处理 Handling Errors"></a>错误处理 Handling Errors</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">axios.get(&apos;user/12345&apos;)</span><br><span class="line">    .catch(function(error)&#123;</span><br><span class="line">        if(error.response)&#123;</span><br><span class="line">            //存在请求，但是服务器的返回一个状态码</span><br><span class="line">            //他们都在2xx之外</span><br><span class="line">            console.log(error.response.data);</span><br><span class="line">            console.log(error.response.status);</span><br><span class="line">            console.log(error.response.headers);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //一些错误是在设置请求时触发的</span><br><span class="line">            console.log(&apos;Error&apos;,error.message);</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(error.config);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>你可以使用 validateStatus 设置选项自定义HTTP状态码的错误范围。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">axios.get(&apos;user/12345&apos;,&#123;</span><br><span class="line">    validateStatus:function(status)&#123;</span><br><span class="line">        return status &lt; 500;//当返回码小于等于500时视为错误</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="取消-Cancellation"><a href="#取消-Cancellation" class="headerlink" title="取消 Cancellation"></a>取消 Cancellation</h5><p>你可以使用 cancel token 取消一个请求</p>
<p>axios的cancel token API是基于<strong>cnacelable promises proposal</strong>，其目前处于第一阶段。<br>你可以使用 CancelToke.source 工厂函数创建一个cancel token，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var CancelToke = axios.CancelToken;</span><br><span class="line">var source = CancelToken.source();</span><br><span class="line"></span><br><span class="line">axios.get(&apos;/user/12345&apos;, &#123;</span><br><span class="line">    cancelToken:source.toke</span><br><span class="line">&#125;).catch(function(thrown)&#123;</span><br><span class="line">    if(axiso.isCancel(thrown))&#123;</span><br><span class="line">        console.log(&apos;Rquest canceled&apos;, thrown.message);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        //handle error</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//取消请求(信息参数设可设置的)</span><br><span class="line">source.cancel(&quot;操作被用户取消&quot;);</span><br></pre></td></tr></table></figure>
<p>你可以给 CancelToken 构造函数传递一个executor function来创建一个cancel token:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var CancelToken = axios.CancelToken;</span><br><span class="line">var cancel;</span><br><span class="line"></span><br><span class="line">axios.get(&apos;/user/12345&apos;, &#123;</span><br><span class="line">    cancelToken: new CancelToken(function executor(c)&#123;</span><br><span class="line">        //这个executor 函数接受一个cancel function作为参数</span><br><span class="line">        cancel = c;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//取消请求</span><br><span class="line">cancel();</span><br></pre></td></tr></table></figure>
<p>注意：你可以使用同一个cancel token取消多个请求。</p>

      
    </div>

    

    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>壕，请用金钱羞辱我！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/static/images/wx.png" alt="zoumeihui 微信支付"/>
        <p>微信支付</p>
      </div>
    

    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>zoumeihui</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://yoursite.com/2018/07/20/2018-07-20-nodejs的stream/" title="nodejs的stream">http://yoursite.com/2018/07/20/2018-07-20-nodejs的stream/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc/4.0/" rel="external nofollow" target="_blank">CC BY-NC 4.0</a> 许可协议。转载请注明出处！</li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/nodejs/" rel="tag"># nodejs</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        
          <div class="wp_rating">
            <div id="wpac-rating"></div>
          </div>
        

        

        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/07/04/2018-07-04-高度自适应布局/" rel="next" title="高度自适应布局">
                <i class="fa fa-chevron-left"></i> 高度自适应布局
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/08/21/2018-08-21-影响外部加在速度/" rel="prev" title="影响网站加载速度之外部资源文件分析">
                影响网站加载速度之外部资源文件分析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://www.gravatar.com/avatar/e87b264d88631de777ecfe2abb602de6?size=128"
                alt="zoumeihui" />
            
              <p class="site-author-name" itemprop="name">zoumeihui</p>
              <p class="site-description motion-element" itemprop="description">End of the road is still the way, if you want to go..</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/zoumeihui" target="_blank" title="GitHub" rel="external nofollow"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://zoumeihui.github.io/2018/06/09/hello-world/" target="_blank" title="Mylog" rel="external nofollow"><i class="fa fa-fw fa-globe"></i>Mylog</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://zoumeihui.github.io/2018/06/09/resume/" target="_blank" title="Resume" rel="external nofollow"><i class="fa fa-fw fa-globe"></i>Resume</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="243912063" target="_blank" title="QQ" rel="external nofollow"><i class="fa fa-fw fa-qq"></i>QQ</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="243912063@qq.com" target="_blank" title="Email" rel="external nofollow"><i class="fa fa-fw fa-envelope"></i>Email</a>
                  
                </span>
              
            </div>
          

          
          
            <div class="cc-license motion-element" itemprop="license">
              <a href="https://creativecommons.org/licenses/by-nc/4.0/" class="cc-opacity" target="_blank" rel="external nofollow">
                <img src="/images/cc-by-nc.svg" alt="Creative Commons" />
              </a>
            </div>
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.baidu.com" title="Search" target="_blank">Search</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#nodejs的stream"><span class="nav-number">1.</span> <span class="nav-text">nodejs的stream</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#一-为什么需要流（Stream）？"><span class="nav-number">1.1.</span> <span class="nav-text">一.  为什么需要流（Stream）？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#二-什么是流（Stream）？"><span class="nav-number">1.2.</span> <span class="nav-text">二. 什么是流（Stream）？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#三-Readable流（可读流）介绍"><span class="nav-number">1.3.</span> <span class="nav-text">三. Readable流（可读流）介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#举个简单的小例子"><span class="nav-number">1.3.1.</span> <span class="nav-text">　　　举个简单的小例子</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#四-Writable流（可写流）介绍"><span class="nav-number">1.4.</span> <span class="nav-text">四. Writable流（可写流）介绍</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Node-js-Buffer-缓冲区"><span class="nav-number">2.</span> <span class="nav-text">Node.js Buffer(缓冲区)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Buffer-与字符编码"><span class="nav-number">2.1.</span> <span class="nav-text">Buffer 与字符编码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#创建-Buffer-类"><span class="nav-number">2.2.</span> <span class="nav-text">创建 Buffer 类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#写入缓冲区"><span class="nav-number">2.3.</span> <span class="nav-text">写入缓冲区</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#语法"><span class="nav-number">2.3.1.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#参数"><span class="nav-number">2.3.2.</span> <span class="nav-text">参数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#返回值"><span class="nav-number">2.3.3.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#实例"><span class="nav-number">2.3.4.</span> <span class="nav-text">实例</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#从缓冲区读取数据"><span class="nav-number">2.4.</span> <span class="nav-text">从缓冲区读取数据</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#语法-1"><span class="nav-number">2.4.1.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#参数-1"><span class="nav-number">2.4.2.</span> <span class="nav-text">参数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#返回值-1"><span class="nav-number">2.4.3.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#实例-1"><span class="nav-number">2.4.4.</span> <span class="nav-text">实例</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#将-Buffer-转换为-JSON-对象"><span class="nav-number">2.5.</span> <span class="nav-text">将 Buffer 转换为 JSON 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#语法-2"><span class="nav-number">2.5.1.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#返回值-2"><span class="nav-number">2.5.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#实例-2"><span class="nav-number">2.5.3.</span> <span class="nav-text">实例</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#缓冲区合并"><span class="nav-number">2.6.</span> <span class="nav-text">缓冲区合并</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#语法-3"><span class="nav-number">2.6.1.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#参数-2"><span class="nav-number">2.6.2.</span> <span class="nav-text">参数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#返回值-3"><span class="nav-number">2.6.3.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#实例-3"><span class="nav-number">2.6.4.</span> <span class="nav-text">实例</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#缓冲区比较"><span class="nav-number">2.7.</span> <span class="nav-text">缓冲区比较</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#语法-4"><span class="nav-number">2.7.1.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#参数-3"><span class="nav-number">2.7.2.</span> <span class="nav-text">参数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#返回值-4"><span class="nav-number">2.7.3.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#实例-4"><span class="nav-number">2.7.4.</span> <span class="nav-text">实例</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#拷贝缓冲区"><span class="nav-number">2.8.</span> <span class="nav-text">拷贝缓冲区</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#语法-5"><span class="nav-number">2.8.1.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#参数-4"><span class="nav-number">2.8.2.</span> <span class="nav-text">参数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#返回值-5"><span class="nav-number">2.8.3.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#实例-5"><span class="nav-number">2.8.4.</span> <span class="nav-text">实例</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#缓冲区裁剪"><span class="nav-number">2.9.</span> <span class="nav-text">缓冲区裁剪</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#参数-5"><span class="nav-number">2.9.1.</span> <span class="nav-text">参数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#返回值-6"><span class="nav-number">2.9.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#实例-6"><span class="nav-number">2.9.3.</span> <span class="nav-text">实例</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#缓冲区长度"><span class="nav-number">2.10.</span> <span class="nav-text">缓冲区长度</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#语法-6"><span class="nav-number">2.10.1.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#返回值-7"><span class="nav-number">2.10.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#实例-7"><span class="nav-number">2.10.3.</span> <span class="nav-text">实例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Stream和Buffer"><span class="nav-number">3.</span> <span class="nav-text">Stream和Buffer</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Stream"><span class="nav-number">3.1.</span> <span class="nav-text">Stream</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Buffer"><span class="nav-number">3.2.</span> <span class="nav-text">Buffer</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-1-Stream"><span class="nav-number">3.2.1.</span> <span class="nav-text">1.1 Stream</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#1-2-Buffer"><span class="nav-number">3.2.2.</span> <span class="nav-text">1.2 Buffer</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Why"><span class="nav-number">3.2.3.</span> <span class="nav-text">Why</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#How"><span class="nav-number">3.3.</span> <span class="nav-text">How</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Different"><span class="nav-number">3.4.</span> <span class="nav-text">Different</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Scene-应用场景）"><span class="nav-number">3.5.</span> <span class="nav-text">Scene(应用场景）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#5-1-Stream的使用场景"><span class="nav-number">3.5.1.</span> <span class="nav-text">5.1 Stream的使用场景</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-2-Buffer的使用场景"><span class="nav-number">3.5.2.</span> <span class="nav-text">5.2 Buffer的使用场景</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#nodejs-buffer-stream区别"><span class="nav-number">3.6.</span> <span class="nav-text">nodejs buffer stream区别</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#buffer"><span class="nav-number">3.6.1.</span> <span class="nav-text">buffer</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#stream"><span class="nav-number">3.6.2.</span> <span class="nav-text">stream</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Node-js-Buffer-缓冲区-和Stream流的关系"><span class="nav-number">4.</span> <span class="nav-text">Node.js Buffer(缓冲区)和Stream流的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vue组件之间的通信"><span class="nav-number">5.</span> <span class="nav-text">vue组件之间的通信</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#父组件向子组件传递数据"><span class="nav-number">5.1.</span> <span class="nav-text">父组件向子组件传递数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#子组件向父组件传递数据"><span class="nav-number">5.2.</span> <span class="nav-text">子组件向父组件传递数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#第二种通信方式-eventBus"><span class="nav-number">5.3.</span> <span class="nav-text">第二种通信方式: eventBus</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#第三种通信方式-利用localStorage或者sessionStorage"><span class="nav-number">5.4.</span> <span class="nav-text">第三种通信方式: 利用localStorage或者sessionStorage</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#第四种通信方式-利用Vuex"><span class="nav-number">5.5.</span> <span class="nav-text">第四种通信方式: 利用Vuex()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#axios中文文档"><span class="nav-number">6.</span> <span class="nav-text">axios中文文档</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#axios"><span class="nav-number">6.1.</span> <span class="nav-text">axios</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#特色"><span class="nav-number">6.2.</span> <span class="nav-text">特色</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#示例"><span class="nav-number">6.3.</span> <span class="nav-text">示例</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#使用一个-GET-请求"><span class="nav-number">6.3.1.</span> <span class="nav-text">使用一个 GET 请求</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#发起一个-POST-请求"><span class="nav-number">6.3.2.</span> <span class="nav-text">发起一个 POST 请求</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#发起一个多重并发请求"><span class="nav-number">6.3.3.</span> <span class="nav-text">发起一个多重并发请求</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#axios-API"><span class="nav-number">6.4.</span> <span class="nav-text">axios API</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#请求方法的重命名。"><span class="nav-number">6.5.</span> <span class="nav-text">请求方法的重命名。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#并发-Concurrency"><span class="nav-number">6.6.</span> <span class="nav-text">并发 Concurrency</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#创建一个实例"><span class="nav-number">6.6.1.</span> <span class="nav-text">创建一个实例</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#实例方法"><span class="nav-number">6.6.2.</span> <span class="nav-text">实例方法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#请求设置"><span class="nav-number">6.7.</span> <span class="nav-text">请求设置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#返回响应概要-Response-Schema"><span class="nav-number">6.8.</span> <span class="nav-text">返回响应概要 Response Schema</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#默认设置（Config-Default"><span class="nav-number">6.9.</span> <span class="nav-text">默认设置（Config Default)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#全局默认设置-Global-axios-defaults"><span class="nav-number">6.10.</span> <span class="nav-text">全局默认设置 Global axios defaults</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#实例中自定义默认值-Custom-instance-default"><span class="nav-number">6.11.</span> <span class="nav-text">实例中自定义默认值 Custom instance default</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#设置优先级-Config-order-of-precedence"><span class="nav-number">6.12.</span> <span class="nav-text">设置优先级 Config order of precedence</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#拦截器-interceptors"><span class="nav-number">6.13.</span> <span class="nav-text">拦截器 interceptors</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#错误处理-Handling-Errors"><span class="nav-number">6.14.</span> <span class="nav-text">错误处理 Handling Errors</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#取消-Cancellation"><span class="nav-number">6.15.</span> <span class="nav-text">取消 Cancellation</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zoumeihui</span>

  

  
</div>


  



  <div class="powered-by">由 <a class="theme-link" target="_blank" rel="external nofollow" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" rel="external nofollow" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.1.0</div>




        








        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.1.0"></script>



  



	





  





  










  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("uOoGuWdXSYaRWVH1yqf8PhRV-gzGzoHsz", "kizKXuyzPm6E7A3BrQRGlj7t");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            
            counter.save(null, {
              success: function(counter) {
                
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(counter.get('time'));
                
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            
              var newcounter = new Counter();
              /* Set ACL */
              var acl = new AV.ACL();
              acl.setPublicReadAccess(true);
              acl.setPublicWriteAccess(true);
              newcounter.setACL(acl);
              /* End Set ACL */
              newcounter.set("title", title);
              newcounter.set("url", url);
              newcounter.set("time", 1);
              newcounter.save(null, {
                success: function(newcounter) {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
                },
                error: function(newcounter, error) {
                  console.log('Failed to create');
                }
              });
            
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  
  
  <script type="text/javascript">
  wpac_init = window.wpac_init || [];
  wpac_init.push({widget: 'Rating', id: 11948,
    el: 'wpac-rating',
    color: 'fc6423'
  });
  (function() {
    if ('WIDGETPACK_LOADED' in window) return;
    WIDGETPACK_LOADED = true;
    var mc = document.createElement('script');
    mc.type = 'text/javascript';
    mc.async = true;
    mc.src = '//embed.widgetpack.com/widget.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
  })();
  </script>


  

  

  

  

</body>
</html>
